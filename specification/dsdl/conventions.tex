\section{Conventions and recommendations}

이번 섹션에서는 데이터 타입 설계자가 일관성 있는 스타일을 유지하는데 도움을 얻을 수 있는 추천 규칙과 일반적인 실수를 피하는 방법에 대해서 다룬다.
이 섹션에서 제공하는 모든 추천 규칙은 반드시 따라야하는 강제성은 없으면 선택할 수 있다.

\subsection{Naming recommendations}

일반 SW 개발 분야에서 널리 사용되는 DSDL 네이밍 추천은 아래와 같다.

\begin{itemize}
    \item Namespaces and field attributes should be named in the \verb|snake_case|.
    \item Constant attributes should be named in the \verb|SCREAMING_SNAKE_CASE|.
    \item Data types (excluding their namespaces) should be named in the \verb|PascalCase|.
    \item Names of message types should form a declarative phrase or a noun. For example,
          \verb|BatteryStatus| or \verb|OutgoingPacket|.
    \item Names of service types should form an imperative phrase or a verb. For example,
          \verb|GetInfo| or \verb|HandleIncomingPacket|.
    \item Short names, unnecessary abbreviations, and uncommon acronyms should be avoided.
\end{itemize}

\subsection{Comments}

모든 데이터 타입 정의 파일에서 시작은 해당 데이터 타입에 대한 상세한 설명, 목적, 사용 패턴, 관련 데어터 교환 패턴, 제약사항 등과 같이 데이터 타입을 사용하는데 유용한 정보를 제공하는 헤더 코멘트로 시작한다.

데이터 타입 정의에 대한 모든 속성과 각 필드의 특별한 속성은 상세한 설명, 목적, 사용 패턴, 관련 데어터 교환 패턴, 제약사항 등을 가지고 있다.
속성 중에 충분한 설명이 제공되고 이름이 의도를 명확하게 나타내는 경우에는 예외가 적용된다.

코멘트는 설명하려는 엔트티 뒤에 위치해야만 한다:
동일한 라인에 있던가 다음 라인에 위치한다.
이런 추천은 파일 헤더 코멘트에는 적용되지 않는다.

% Field comment placement https://forum.uavcan.org/t/dsdl-documentation-comments/407

\subsection{Optional value representation}

자료구조에는 항상 존재하지 않을 수 있는 옵션 필드 속성을 포함할 수도 있다.

옵션 필드 속성을 표현하는 추천 접근법은 하나의 엘리멘트로 가변 길이 배열을 사용하는 것이다.

다른 방법은 이런 1개짜리 엘리멘트 가변 길이 배열은 2개짜리 필드 unions로 대체가 가능하다. 여기서 첫번째 필드는 비어 있고 두번째 필드는 원하는 옵션 값을 포함한다.
원하는 레이아웃은 위에서 설명한 의미상 1개짜리 엘리멘트 배열과 호환되고 필드 속성이 스왑되지 않았다는 것을 제공한다.

Floating-point-typed 필드 속성은 IEEE 754 NaN의 값이 할당될 수 있다. 이것은 해당 값이 지정되지 않았다는 것을 나타낸다.:
하지만 이런 패턴은 해당 값이 존재하지 않더라도 버스 상에서 전송되어야 하는데 못하고 있으므로 사용하지 않는다. 그리고 이런 특별한 값은 타입 안전성을 헤친다.

\begin{remark}[breakable]
    Array-based optional field:

    \begin{minted}{python}
        MyType[<=1] optional_field
    \end{minted}

    Union-based optional field:

    \begin{minted}{python}
        @sealed                         # Sic!
        @union                          # The implicit tag is one byte long.
        uavcan.primitive.Empty none     # Represents lack of value, unpopulated field.
        MyType some                     # The field of interest; field ordering is important.
    \end{minted}

    The defined above union can be used as follows (suppose it is named \verb|MaybeMyType|):

    \begin{minted}{python}
        MaybeMyType optional_field
    \end{minted}

    The shown approaches are semantically compatible.
\end{remark}

\begin{remark}[breakable]
    The implicit truncation and the implicit zero extension rules allow one to freely add such optional fields
    at the end of a definition while retaining semantic compatibility.
    The implicit truncation rule will render them invisible to nodes that utilize older data type definitions
    which do not contain them, whereas nodes that utilize newer definitions will be able to correctly process
    objects serialized using older definitions because the implicit zero extension rule guarantees
    that the optional fields will appear unpopulated.

    For example, let the following be the old message definition:

    \begin{minted}{python}
        float64 foo
        float32 bar
    \end{minted}

    The new message definition with the new field is as follows:

    \begin{minted}{python}
        float64 foo
        float32 bar
        MyType[<=1] my_new_field
    \end{minted}

    Suppose that one node is publishing a message using the old definition,
    and another node is receiving it using the new definition.
    The implicit zero extension rule guarantees that the optional field array will
    appear empty to the receiving node because the implicit length field will be read as zero.
    Same is true if the message was nested inside another one, thanks to the delimiter header.
\end{remark}

\subsection{Bit flag representation}

비트 플래그들의 집합을 정의하는 추천 방법은 각각에 대해서 \verb|bool|-타입 필드 속성을 명시하는 것이다.
2의 자승의 정수 합을\footnote{Which are popular in programming.} 기반으로 하는 표현은 의도를 명확히 드러내는데 모호하므로 사용하지 않는다.

\begin{remark}
    Recommended approach:

    \begin{minted}{python}
        void5
        bool flag_foo
        bool flag_bar
        bool flag_baz
    \end{minted}

    Not recommended:

    \begin{minted}{python}
        uint8 flags             # Not recommended
        uint8 FLAG_BAZ = 1
        uint8 FLAG_BAR = 2
        uint8 FLAG_FOO = 4
    \end{minted}
\end{remark}
