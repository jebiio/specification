\section{Attributes}\label{sec:dsdl_attributes}

\emph{attribute}는 특정 객체나 타입과 관련된 이름이 붙여진 엔트티이다.(패딩 필드는 제외)

\subsection{Composite type attributes}

데이터 타입 정의 시간에 할당되는 값을 가지는 컴포지트 타입 속성을 \emph{constant attribute}라고 부른다.
데이터 타입 정의 시간에 할당되는 않는 컴포지트 타입 속성을 \emph{field attribute}라고 부른다.

컴포지트 타입 속성의 이름은 이를 포함하는 데이터 타입 정의 내에서는 유일한 이름이 되며,
table
\ref{table:dsdl_reserved_word_patterns}에서 정의한 예약 이름 패턴과 매칭되지 않는다.
이런 요구사항은 패딩 필드에 적용되지 않는다.

\subsubsection{Field attributes}

필드 속성은 정적으로 정의된 타입의 동적으로 할당된 값을 나타내며 포함하고 있는 객체의 하나의 멤버로 네트워크 상에서 교환이 가능하다.
필드 속성의 데이터 타입은 직렬화 가능한 타입의 카테고리(section~\ref{sec:dsdl_serializable_types})가 될 수 있으며,
void 타입 카테고리는 허용하지 않아서 제외된다.

필드 속성의 특수한 종류--- \emph{padding fields}에 예외가 적용된다.
패딩 필드 속성의 타입은 void 카테고리의 타입이 된다.
패딩 필드 속성은 이름을 갖지 않을 것이다.

필드 속성 한쌍이 동일하다고 판단되는 경우는 양쪽 모두 동일한 속성이고 모두 동일한 이름 이거나 패딩 필드 속성인 경우이다.

\begin{remark}
    Example:
    \begin{minted}{python}
        uint8[<=10] regular_field   # A field named "regular field"
        void16                      # A padding field; no name is permitted
    \end{minted}
\end{remark}

\subsubsection{Constant attributes}

상수 속성은 정적으로 정의된 타입에 이름을 갖는 정적으로 할당된 값을 표현한다.
상수 속성의 값은 네트워크 상에서 절대로 교환할 수 없다.
왜냐하면 데이터 타입의 동일한 정의를 공유하는 방식으로 관련된 모든 노드들이 모두 사전에 알고 있다고 가정한다.

상수 속성의 데이터 타입은 원시 타입이된다.
카테고리
(section~\ref{sec:dsdl_serializable_types})

상수 속성의 값은 \emph{initialization expression}를 evaluation으로 DSDL 정의 처리 시점에 결정된다.

구문은 상수 속성의 값을 초기화하기 위해서 evaluation에 따라서 호환되는 타입을 생성한다.
호환 타입의 집합은 초기화되는 상수 속성의 타입에 의존하며 table~\ref{table:dsdl_constant_init_pattern}에서 지정되어 있다.

\begin{UAVCANSimpleTable}[wide]{Permitted constant attribute value initialization patterns}{|l | X | X[2] | X[2]|}
    \diagbox[font=\footnotesize]{Constant\\type\\category}{Expression\\type} &
    \texttt{bool} & \texttt{rational} & \texttt{string} \\

    \textbf{Boolean} &
    Allowed. &
    Not allowed. &
    Not allowed. \\

    \textbf{Integer} &
    Not allowed. &
    Allowed if the denominator equals one and the numerator value is within the range of the constant type. &
    Allowed if the target type is \texttt{uint8} and the source string contains one symbol whose code point falls
    into the range $[0, 127]$. \\

    \textbf{Floating point} &
    Not allowed. &
    Allowed if the source value does not exceed the finite range of the constant type.
    The final value is computed as the quotient of the numerator and the denominator
    with implementation-defined accuracy. &
    Not allowed. \label{table:dsdl_constant_init_pattern}\\

\end{UAVCANSimpleTable}

데이터 타입 정의 시점에 정의한 상수 속성의 값으로 인해,
원시 타입으로 된 상수의 캐스트 모드는 관찰 영향을 가지고 있지 않다.

\begin{remark}
    A real literal \verb|1234.5678| is represented internally as
    $\frac{6172839}{5000}$, which can be used to initialize a \verb|float16| value,
    resulting in $1235.0$.

    The specification states that the value of a floating-point constant should be computed
    with an implementation-defined accuracy. UAVCAN avoids strict accuracy requirements in order to
    ensure compatibility with implementations that rely on non-standard floating point formats.
    Such laxity in the specification is considered acceptable since the uncertainty is always
    confined to a single division expression per constant; all preceding computations, if any,
    are always performed by the DSDL compiler using exact rational arithmetic.
\end{remark}

\subsection{Local attributes}\label{sec:dsdl_local_attributes}

로컬 속성은 DSDL 정의 처리 시간에 유효하다.
section~\ref{sec:dsdl_grammar}에 정의된 것과 같이,
DSDL 정의는 순서를 가지는 구문들을 모아둔 것이다.
구문 넘버 $E$ 에 포함된 expression은 이름으로 구문 넘버 $A$ 에서 말한 컴포지트 타입 속성을 뜻한다. 여기서 $A < E$ 와 양쪽 구문이 동일한 데이터 타입 definition\footnote{
    Per \ref{sec:dsdl_elements_of_data_type_definition},
    in case of services, this applies only to their request and response types.
}에 속한다.
참조한 DSDL expression의 컨텍스트에서 참조한 속성의 표현은 table~\ref{table:dsdl_local_attribute_representation}에 지정되어 있다.

\begin{UAVCANSimpleTable}{Local attribute representation}{|l X X|}\label{table:dsdl_local_attribute_representation}%
    Attribute category & Value type & Value \\

    Constant attribute &
    Type of the constant attribute &
    Value of the constant attribute \\

%    Field attribute &
%    \texttt{metaserializable} &
%    Type of the field attribute \\
    Field attribute &
    Illegal &
    Illegal \\

\end{UAVCANSimpleTable}

\begin{remark}
    \begin{minted}{python}
        uint8 FOO = 123
        uint16 BAR = FOO ** 2
        @assert BAR == 15129
        ---  # The request type ends here; its attributes are no longer accessible.
        #uint16 BAZ = BAR  # Would fail - BAR is not accessible here.
        float64 FOO = 3.14
        @assert FOO == 3.14
    \end{minted}
\end{remark}

\subsection{Intrinsic attributes}

고유한 속성은 어떤 expression에서 든 유효하다.
이 값들은 컨텍스트에 따라서 DSDL 처리 툴에 의해서 생성되며,
이번 섹션에서 다룬다.

\subsubsection{Offset attribute}

오프셋 속성은 식별자 ``\verb|_offset_|''를 뜻한다.
이 값은 type $\texttt{set}_\texttt{<rational>}$의 값이다.

다음 텍스트에서 용어 \emph{referring statement}은 오프셋 속성을 참조하는 expression을 포함하는 구문을 뜻한다.
용어 \emph{bit length set}은 section~\ref{sec:dsdl_bit_length_set}에 정의되어 있다.

속성의 값은 필드 속성 선언의 기능으로 참조 구문 앞에 위치하고 포함하는 정의의 카테고리이다.

현재 정의가 태그된 union 카테고리에 속한다면,
참조 구문은 최종 필드 속성 정의 뒤에 위치하게 된다.
참조 구문에 이후에 있는 필드 속성 정의는 현재 정의가 유효하지 않다고 판단하게 된다.
태그 unions에 대해서 오프셋 속성의 값은 unions 필드의 누적 bit length set\footnote{Section \ref{sec:dsdl_composite_alignment_cumulative_bls}}로 정의한다. 여기서 해당 집합의 각 엘리멘트는 내포된 union 태그 필드의(section \ref{sec:dsdl_serialization_composite}) bit length만큼 증가시킨다.

현재 데이터 정의는 태그된 union 카테고리에 속하지 않지만,
참조 구문은 현재 정의 내부에 어떤 곳이든 위치할 수 있다.
오프셋 속성의 값은 참조 구문(see section~\ref{sec:dsdl_grammar} on statement ordering) 앞에 있는 구문에서 필드의 누적 bit length set\footnote{Section \ref{sec:dsdl_composite_alignment_cumulative_bls}.}로 정의된다.

\begin{remark}
    \begin{minted}{python}
        @union
        uint8 a
        #@print _offset_  # Would fail: it's a tagged union, _offset_ is undefined until after the last field
        uint16 b
        @assert _offset_ == {8 + 8,  8 + 16}
        ---
        @assert _offset_ == {0}
        float16 a
        @assert _offset_ == {16}
        void4
        @assert _offset_ == {20}
        int4 b
        @assert _offset_ == {24}
        uint8[<4] c
        @assert _offset_ == 8 + {24,  32,  40,  48}
        @assert _offset_ % 8 == {0}
        # One of the main usages for _offset_ is statically proving that the following field is byte-aligned
        # for all possible valid serialized representations of the preceding fields. It is done by computing
        # a remainder as shown above. If the field is aligned, the remainder set will equal {0}. If the
        # remainder set contains other elements, the field may be misaligned under some circumstances.
        # If the remainder set does not contain zero, the field is never aligned.
        uint8 well_aligned   # Proven to be byte-aligned.
    \end{minted}
\end{remark}
