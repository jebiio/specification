\section{Architecture}

\subsection{General principles}

UAVCAN 아키텍처에 따라 DSDL에서 사용자는 2가지 종류의 데이터 타입을 정의할 수 있다:
메시지 타입과 서비스 타입
메시지 타입은 publish-subscribe 상에서 데이터 교환에 사용되며 1:다 메시지 링크는 서브젝트-ID로 식별한다. 서비스 타입은 request-response를 수행하는데 사용하며 RPC와 같이 1:1 교환에서 서비스-ID로 식별한다.
서비스 타입은 정확히 2개 내부 데이터 타입으로 구성된다:
그 중에 하나는 request 타입(클라이언트에서 서버로 전송)이고,
나머지 하나는 response 타입(서버에서 클라이언트로 전송)이다.

UAVCAN의 deterministic 속성을 따라서 메시지나 서비스 객체의 크기는 정적으로 이미 알고 있는 크기 이내에 한정된다.
가변길이 엔트티는 항상 데이터 타입 디자이너가 정의한 고정 길이 제한을 가진다.

DSDL정의는 정적 타입이다.

DSDL은 데이터 타입 버전관리를 위해 잘 정의되어 있다. 이를 통해 데이터 타입 유지보수자가 배포한 데이터 타입의 하위 호환을 되도록 변경할 수 있다.

DSDL은 확장 가능한 정적 분석을 지원하도록 설계되었다. 하위 바이너리 호환성과 데이터 필드 레이아웃과 같이 데이터 타입 정의의 중요한 속성은 이를 사용하는 시스템이 운영되기 전에 자동 소프트웨어 도구로 검증 및 검사가 가능하다.

DSDL정의는 타겟 프로그래밍 언어에서 직렬화 소스코드 데이터 타입으로 자동 생성될 수 있다.
DSDL 정의를 기반으로 직렬화 코드를 생성하는 기능을 가진 도구를 \emph{DSDL compiler}라고 부른다.
좀더 일반적으로는 말하자면 DSDL 정의로 동작하도록 설계된 소프트웨어 도구를 \emph{DSDL processing tool}라고 부른다.

\subsection{Data types and namespaces}

모든 데이터 타입은 \emph{namespace} 내부에 위치한다.
네임스페이스는 더 상위레벨 네임스페이스에 포함될 수 있으며 트리구조를 가진다.

트리 구조의 최상단에 있는 네임스페이스를 \emph{root namespace}라고 부른다.
다른 네임스페이스 내부에 위치하고 있는 네임스페이스를 \emph{nested namespace}라고 부른다.

데이터 타입은 네임스페이스와 이름\emph{short name}으로 식별된다.
데이터 타입의 이름은 네임스페이트를 제외한 타입의 이름이다.

데이터 타입의 \emph{full name}은 이름과 네임스페이스 이름들로 구성된다.전체 이름에 포함된 이름과 네임스페이스는를 \emph{name components}라고 부른다.
이름 컴포넌트들은 순서를 가진다: 루트 네임스페이스는 항상 맨 앞에 오고 다음으로 nested 네임스페이스가 온다.
전체 이름에서 이름(short name)은 항상 마지막에 위치한다.
전체 이름은 ASCII dot 문자 ``\verb|.|'' (ASCII code 46)를 통해서 이름 컴포넌트들을 연결시킨다.

\emph{full namespace} 이름은 이름(short name)과 component 구분자를 제외한 전체 이름이다.

\emph{sub-root namespace}은 netsted 네임스페이스로 루트 네임스페이스 바로 밑에 위치한다.
루트 네임스페이스 아래에 위치하고 있는 데이터 타입은 하위루트 네임스페이스를 가지지 않는다.

이름 구조는 figure~\ref{fig:dsdl_data_type_name_structure} 그림으로 표현하였다.

\begin{figure}[H]
    $$
    \overbrace{
        \underbrace{
            \underbrace{\texttt{\huge{uavcan}}}_{\substack{\text{root} \\ \text{namespace}}}%
            \texttt{\huge{.}}%
            \underbrace{\texttt{\huge{node}}}_{\substack{\text{nested, also} \\ \text{sub-root} \\ \text{namespace}}}%
            \texttt{\huge{.}}%
            \underbrace{\texttt{\huge{port}}}_{\substack{\text{nested} \\ \text{namespace}}}%
        }_{\text{full namespace}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{GetInfo}}}_{\text{short name}}
    }^{\text{full name}}
    $$
    \caption{Data type name structure\label{fig:dsdl_data_type_name_structure}}
\end{figure}

전체 네임스페이스 이름의 집합과 전체 데이터 타입 이름의 집합은 서로 교차되지 않는다.\footnote{%
    예제로 네임스페이스 ``\texttt{vendor.example}''와 데이터 타입 ``\texttt{vendor.example.1.0}''는 서로 상호배제되는 형태다.
    이 예제에서 보여준 데이터 타입 이름은 이름 규칙에 위배된다. 이는 별도 섹션에서 다룰 예정이다.
}.

데이터 타입 이름과 네임스페이스 이름은 대소문자를 구분한다.
하지만 대소문자가 다른 이름들은 허용하지 않는다.\footnote{%
    대소문자를 구분하지 않는 파일시스템에서는 문제를 야기할 수 있기 때문이다.
}.
다시 말하면 대소문자만 다른 한쌍의 이름은 이름 충돌이 발생할 수 있다.

이름 컴포넌트는 알파벳 ASCII 문자와(\verb|A-Z|, \verb|a-z|, \verb|0-9|) 언더스코어 (``\verb|_|'', ASCII code 95)로 구성되어 있다.
빈 문자열은 이름 컴포넌트로 유효하지 않다.
이름 컴포넌트의 첫번째 문자는 숫자가 올 수 없다.
이름 컴포넌트에는 어떠한 예약 워드 패턴도 패칭되지 않으며 목록은 table~\ref{table:dsdl_reserved_word_patterns}을 참조하자.

전체 데이터 타입 이름의 길이는 255문자를 초과하지 않는다.\footnote{This includes the name component separators, but not the version.}

모든 데이터 타입 정의는 메이저와 마이너 버전 넘버 쌍을 할당한다.
데이터 타입 정의를 식별하기 위해서 버전 넘버가 지정된다.
다음 텍스트에서 majority qualifier가 없는 \emph{version}는 용어는 메이저와 마이너 버전 넘버 쌍을 의미한다.

유효 데이터 타입 버전 넘버는 0에서 255의 범위를 가진다.
메이저와 마이너 컴포넌트 모두 0인 데이터 타입 버전은 허용하지 않는다.

\subsection{File hierarchy}

DSDL 데이터 타입 정의는 파일 이름 확장자가 \verb|.uavcan|이고 UTF-8로 인코딩된 텍스트 파일이다.

하나의 파일은 정확히 하나의 버전의 데이터 타입을 정의하며 메이저와 마이너 버전의 각 조합은 데이터 타입 이름에 대해서 유일하게 된다.
서동일한 데이터 타입에 대해서 서로 동시에 임의의 버전 넘버가 가능하며 각 버전은 기껏해야 한 번 정의될 수 있다.
버전 넘버 순서는 연속되는 수일 필요는 없으며 버전 넘버를 건너 뛰거나 가장 오래되거나 가장 최신인 기존 정의만 아니라면 제거도 가능하다.

데이터 타입 정의는 옵션으로 고정된 port-ID\footnote{Chapter~\ref{sec:basic}.} 지정 값이다.

데이터 타입 정의 파일의 이름은 엔트티와 ASCII dot 문자 ``\verb|.|'' (ASCII code 46)로 지정한 순서로 구성된다. :
\begin{itemize}
    \item 10진수의 고정 port-ID, 고정 port-ID가 이 정의에서 제공되는 경우
    \item 데이터 타입의 short name (필수, 공백 허용 하지 않음).
    \item 10진수의 메이저 버전 넘버 (필수)
    \item 10진수의 마이너 버전 넘버 (필수)
    \item 파일 이름 확장자 ``\verb|uavcan|'' (필수).
\end{itemize}

\begin{figure}[H]
    $$
    \overbrace{%
        \underbrace{\texttt{\huge{432}}}_{\substack{\text{fixed} \\ \text{port-ID}}}%
        \texttt{\huge{.}}%
    }^{\text{optional}}%
    \overbrace{%
        \underbrace{\texttt{\huge{GetInfo}}}_{\substack{\text{short name}}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{1.0}}}_{\substack{\text{version} \\ \text{numbers}}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{uavcan}}}_{\text{file extension}}%
    }^{\text{mandatory}}
    $$
    \caption{Data type definition file name structure\label{fig:dsdl_definition_file_name_structure}}
\end{figure}

DSDL 네임스페이스는 디렉토리를 나타낸다. 하나의 디렉토리는 정확히 하나의 네임스페이스를 정의하며 내부에 다른 디렉토리를 가질 수 있다.
디렉토리의 이름은 데이터 타입 이름 컴포넌트의 이름을 정의한다.
하나의 네임스페이스를 정의하고 있는 하나의 디렉토리는 전체에서의 사용되는 하나의 네임스페이스를 정의한다. 즉 하나의 네임스페이스의 내용은 동일한 이름을 공유하는 다른 디렉토리와 교차로 사용할 수 없다.
하나의 디렉토리는 
nesting\footnote{%
    For example, ``\texttt{foo.bar}'' is not a valid directory name.
    The valid representation would be ``\texttt{bar}'' nested in ``\texttt{foo}''.
}의 한단계 레벨 이상을 정의할 수 없다.

\begin{remark}
    \begin{figure}[H]
        \begin{tabu}{|l|X|} \hline
            \rowfont{\bfseries}
            Directory tree & Entry description \\\hline

            \texttt{vendor\_x/} &
            Root namespace \texttt{vendor\_x}. \\\cline{2-2}

            \texttt{\qquad{}foo/} &
            Nested namespace (also sub-root) \texttt{vendor\_x.foo}. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}100.Run.1.0.uavcan} &
            Data type definition v1.0 with fixed service-ID 100. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}100.Status.1.0.uavcan} &
            Data type definition v1.0 with fixed subject-ID 100. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}ID.1.0.uavcan} &
            Data type definition v1.0 without fixed port-ID. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}ID.1.1.uavcan} &
            Data type definition v1.1 without fixed port-ID. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}bar\_42/} &
            Nested namespace \texttt{vendor\_x.foo.bar\_42}. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}101.List.1.0.uavcan} &
            Data type definition v1.0 with fixed service-ID 101. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}102.List.2.0.uavcan} &
            Data type definition v2.0 with fixed service-ID 102. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}ID.1.0.uavcan} &
            Data type definition v1.0 without fixed port-ID. \\\hline
        \end{tabu}
        \caption{DSDL directory structure example}\label{fig:dsdl_directory_structure_example}
    \end{figure}
\end{remark}

\subsection{Elements of data type definition}\label{sec:dsdl_elements_of_data_type_definition}

A data type definition file contains an exhaustive description of a particular version of the said data type in the
\emph{data structure description language} (DSDL).

A data type definition contains an ordered, possibly empty collection of \emph{field attributes} and/or
unordered, possibly empty collection of \emph{constant attributes}.

A data type may describe either a \emph{structure object} or a \emph{tagged union object}.
The value of a structure object is a function of the values of all of its field attributes.
A tagged union object is formed from at least two field attributes,
but it is capable of holding exactly one field attribute value at any given time.
The value of a tagged union object is a function of which field attribute value
it is holding at the moment and the value of said field attribute.

A field attribute represents a named dynamically assigned value of a statically defined type
that can be exchanged over the network as a member of its containing object.
A padding field attribute is a special kind of field attribute which is used for data alignment purposes;
such field attributes are not named.

A constant attribute represents a named statically defined value of a statically defined type.
Constants are never exchanged over the network, since they are assumed to be known to all involved nodes
by virtue of them sharing compatible definitions of the data type.

Constant values are defined via \emph{DSDL expressions},
which are evaluated at the time of DSDL definition processing.
There is a special category of types called \emph{expression types},
instances of which are used only during expression evaluation
and cannot be exchanged over the network.

Data type definitions can also contain various auxiliary elements reviewed later,
such as deprecation markers (notifying its users that the data type is no longer recommended for new designs)
or assertions (special statements introduced by data type designers
which are statically validated by DSDL processing tools).

Service type definitions are a special case:
they cannot be instantiated or serialized, they do not contain attributes,
and they are composed of exactly two inner data type definitions\footnote{
    A service type can be thought of as a specialized namespace that contains two types and
    has some of the properties of a type, such as name and version.
}.
These inner types are the service request type and the service response type,
separated by the \emph{service response marker}.
They are otherwise ordinary data types except that they are unutterable\footnote{%
    Cannot be referred to. Another commonly used term is ``Voldemort type''.
}
and they derive some of their properties\footnote{Like version numbers or deprecation status.}
from their \emph{parent service type}.

\subsection{Serialization}

Every object that can be exchanged between UAVCAN nodes has a well-defined \emph{serialized representation}.
The value and meaning of an object can be unambiguously recovered from its serialized representation,
provided that the type of the object is known.
Such recovery process is called \emph{deserialization}.

\label{sec:dsdl_bit_length_set}
A serialized representation is a sequence of binary digits (bits);
the number of bits in a serialized representation is called its \emph{bit length}.
A \emph{bit length set} of a data type refers to the set of bit length values of all possible
serialized representations of objects that are instances of the data type.

A data type whose bit length set contains more than one element is said to be \emph{variable length}.
The opposite case is referred to as \emph{fixed length}.

The data type of a serialized message or service object exchanged over the network
is recovered from its subject-ID or service-ID, respectively,
which is attached to the serialized object, along with other metadata, in a manner dictated by the applicable
transport layer specification (chapter~\ref{sec:transport}).
For more information on port identifiers and data type mapping refer to section~\ref{sec:basic_subjects_and_services}.

The bit length set is not defined on service types (only on their request and response types)
because they cannot be instantiated.
