\section{Architecture}

\subsection{General principles}

UAVCAN 아키텍처에 따라 DSDL에서 사용자는 2가지 종류의 데이터 타입을 정의할 수 있다:
메시지 타입과 서비스 타입
메시지 타입은 publish-subscribe 상에서 데이터 교환에 사용되며 1:다 메시지 링크는 서브젝트-ID로 식별한다. 서비스 타입은 request-response를 수행하는데 사용하며 RPC와 같이 1:1 교환에서 서비스-ID로 식별한다.
서비스 타입은 정확히 2개 내부 데이터 타입으로 구성된다:
그 중에 하나는 request 타입(클라이언트에서 서버로 전송)이고,
나머지 하나는 response 타입(서버에서 클라이언트로 전송)이다.

UAVCAN의 deterministic 속성을 따라서 메시지나 서비스 객체의 크기는 정적으로 이미 알고 있는 크기 이내에 한정된다.
가변길이 엔트티는 항상 데이터 타입 디자이너가 정의한 고정 길이 제한을 가진다.

DSDL정의는 정적 타입이다.

DSDL은 데이터 타입 버전관리를 위해 잘 정의되어 있다. 이를 통해 데이터 타입 유지보수자가 배포한 데이터 타입의 하위 호환을 되도록 변경할 수 있다.

DSDL은 확장 가능한 정적 분석을 지원하도록 설계되었다. 하위 바이너리 호환성과 데이터 필드 레이아웃과 같이 데이터 타입 정의의 중요한 속성은 이를 사용하는 시스템이 운영되기 전에 자동 소프트웨어 도구로 검증 및 검사가 가능하다.

DSDL정의는 타겟 프로그래밍 언어에서 직렬화 소스코드 데이터 타입으로 자동 생성될 수 있다.
DSDL 정의를 기반으로 직렬화 코드를 생성하는 기능을 가진 도구를 \emph{DSDL compiler}라고 부른다.
좀더 일반적으로는 말하자면 DSDL 정의로 동작하도록 설계된 소프트웨어 도구를 \emph{DSDL processing tool}라고 부른다.

\subsection{Data types and namespaces}

모든 데이터 타입은 \emph{namespace} 내부에 위치한다.
네임스페이스는 더 상위레벨 네임스페이스에 포함될 수 있으며 트리구조를 가진다.

트리 구조의 최상단에 있는 네임스페이스를 \emph{root namespace}라고 부른다.
다른 네임스페이스 내부에 위치하고 있는 네임스페이스를 \emph{nested namespace}라고 부른다.

데이터 타입은 네임스페이스와 이름\emph{short name}으로 식별된다.
데이터 타입의 이름은 네임스페이트를 제외한 타입의 이름이다.

데이터 타입의 \emph{full name}은 이름과 네임스페이스 이름들로 구성된다.전체 이름에 포함된 이름과 네임스페이스는를 \emph{name components}라고 부른다.
이름 컴포넌트들은 순서를 가진다: 루트 네임스페이스는 항상 맨 앞에 오고 다음으로 nested 네임스페이스가 온다.
전체 이름에서 이름(short name)은 항상 마지막에 위치한다.
전체 이름은 ASCII dot 문자 ``\verb|.|'' (ASCII code 46)를 통해서 이름 컴포넌트들을 연결시킨다.

\emph{full namespace} 이름은 이름(short name)과 component 구분자를 제외한 전체 이름이다.

\emph{sub-root namespace}은 netsted 네임스페이스로 루트 네임스페이스 바로 밑에 위치한다.
루트 네임스페이스 아래에 위치하고 있는 데이터 타입은 하위루트 네임스페이스를 가지지 않는다.

이름 구조는 figure~\ref{fig:dsdl_data_type_name_structure} 그림으로 표현하였다.

\begin{figure}[H]
    $$
    \overbrace{
        \underbrace{
            \underbrace{\texttt{\huge{uavcan}}}_{\substack{\text{root} \\ \text{namespace}}}%
            \texttt{\huge{.}}%
            \underbrace{\texttt{\huge{node}}}_{\substack{\text{nested, also} \\ \text{sub-root} \\ \text{namespace}}}%
            \texttt{\huge{.}}%
            \underbrace{\texttt{\huge{port}}}_{\substack{\text{nested} \\ \text{namespace}}}%
        }_{\text{full namespace}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{GetInfo}}}_{\text{short name}}
    }^{\text{full name}}
    $$
    \caption{Data type name structure\label{fig:dsdl_data_type_name_structure}}
\end{figure}

전체 네임스페이스 이름의 집합과 전체 데이터 타입 이름의 집합은 서로 교차되지 않는다.\footnote{%
    예제로 네임스페이스 ``\texttt{vendor.example}''와 데이터 타입 ``\texttt{vendor.example.1.0}''는 서로 상호배제되는 형태다.
    이 예제에서 보여준 데이터 타입 이름은 이름 규칙에 위배된다. 이는 별도 섹션에서 다룰 예정이다.
}.

데이터 타입 이름과 네임스페이스 이름은 대소문자를 구분한다.
하지만 대소문자가 다른 이름들은 허용하지 않는다.\footnote{%
    대소문자를 구분하지 않는 파일시스템에서는 문제를 야기할 수 있기 때문이다.
}.
다시 말하면 대소문자만 다른 한쌍의 이름은 이름 충돌이 발생할 수 있다.

이름 컴포넌트는 알파벳 ASCII 문자와(\verb|A-Z|, \verb|a-z|, \verb|0-9|) 언더스코어 (``\verb|_|'', ASCII code 95)로 구성되어 있다.
빈 문자열은 이름 컴포넌트로 유효하지 않다.
이름 컴포넌트의 첫번째 문자는 숫자가 올 수 없다.
이름 컴포넌트에는 어떠한 예약 워드 패턴도 패칭되지 않으며 목록은 table~\ref{table:dsdl_reserved_word_patterns}을 참조하자.

전체 데이터 타입 이름의 길이는 255문자를 초과하지 않는다.\footnote{This includes the name component separators, but not the version.}

모든 데이터 타입 정의는 메이저와 마이너 버전 넘버 쌍을 할당한다.
데이터 타입 정의를 식별하기 위해서 버전 넘버가 지정된다.
다음 텍스트에서 majority qualifier가 없는 \emph{version}는 용어는 메이저와 마이너 버전 넘버 쌍을 의미한다.

유효 데이터 타입 버전 넘버는 0에서 255의 범위를 가진다.
메이저와 마이너 컴포넌트 모두 0인 데이터 타입 버전은 허용하지 않는다.

\subsection{File hierarchy}

DSDL 데이터 타입 정의는 파일 이름 확장자가 \verb|.uavcan|이고 UTF-8로 인코딩된 텍스트 파일이다.

하나의 파일은 정확히 하나의 버전의 데이터 타입을 정의하며 메이저와 마이너 버전의 각 조합은 데이터 타입 이름에 대해서 유일하게 된다.
서동일한 데이터 타입에 대해서 서로 동시에 임의의 버전 넘버가 가능하며 각 버전은 기껏해야 한 번 정의될 수 있다.
버전 넘버 순서는 연속되는 수일 필요는 없으며 버전 넘버를 건너 뛰거나 가장 오래되거나 가장 최신인 기존 정의만 아니라면 제거도 가능하다.

데이터 타입 정의는 옵션으로 고정된 port-ID\footnote{Chapter~\ref{sec:basic}.} 지정 값이다.

데이터 타입 정의 파일의 이름은 엔트티와 ASCII dot 문자 ``\verb|.|'' (ASCII code 46)로 지정한 순서로 구성된다. :
\begin{itemize}
    \item 10진수의 고정 port-ID, 고정 port-ID가 이 정의에서 제공되는 경우
    \item 데이터 타입의 short name (필수, 공백 허용 하지 않음).
    \item 10진수의 메이저 버전 넘버 (필수)
    \item 10진수의 마이너 버전 넘버 (필수)
    \item 파일 이름 확장자 ``\verb|uavcan|'' (필수).
\end{itemize}

\begin{figure}[H]
    $$
    \overbrace{%
        \underbrace{\texttt{\huge{432}}}_{\substack{\text{fixed} \\ \text{port-ID}}}%
        \texttt{\huge{.}}%
    }^{\text{optional}}%
    \overbrace{%
        \underbrace{\texttt{\huge{GetInfo}}}_{\substack{\text{short name}}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{1.0}}}_{\substack{\text{version} \\ \text{numbers}}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{uavcan}}}_{\text{file extension}}%
    }^{\text{mandatory}}
    $$
    \caption{Data type definition file name structure\label{fig:dsdl_definition_file_name_structure}}
\end{figure}

DSDL 네임스페이스는 디렉토리를 나타낸다. 하나의 디렉토리는 정확히 하나의 네임스페이스를 정의하며 내부에 다른 디렉토리를 가질 수 있다.
디렉토리의 이름은 데이터 타입 이름 컴포넌트의 이름을 정의한다.
하나의 네임스페이스를 정의하고 있는 하나의 디렉토리는 전체에서의 사용되는 하나의 네임스페이스를 정의한다. 즉 하나의 네임스페이스의 내용은 동일한 이름을 공유하는 다른 디렉토리와 교차로 사용할 수 없다.
하나의 디렉토리는 
nesting\footnote{%
    For example, ``\texttt{foo.bar}'' is not a valid directory name.
    The valid representation would be ``\texttt{bar}'' nested in ``\texttt{foo}''.
}의 한단계 레벨 이상을 정의할 수 없다.

\begin{remark}
    \begin{figure}[H]
        \begin{tabu}{|l|X|} \hline
            \rowfont{\bfseries}
            Directory tree & Entry description \\\hline

            \texttt{vendor\_x/} &
            Root namespace \texttt{vendor\_x}. \\\cline{2-2}

            \texttt{\qquad{}foo/} &
            Nested namespace (also sub-root) \texttt{vendor\_x.foo}. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}100.Run.1.0.uavcan} &
            Data type definition v1.0 with fixed service-ID 100. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}100.Status.1.0.uavcan} &
            Data type definition v1.0 with fixed subject-ID 100. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}ID.1.0.uavcan} &
            Data type definition v1.0 without fixed port-ID. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}ID.1.1.uavcan} &
            Data type definition v1.1 without fixed port-ID. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}bar\_42/} &
            Nested namespace \texttt{vendor\_x.foo.bar\_42}. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}101.List.1.0.uavcan} &
            Data type definition v1.0 with fixed service-ID 101. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}102.List.2.0.uavcan} &
            Data type definition v2.0 with fixed service-ID 102. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}ID.1.0.uavcan} &
            Data type definition v1.0 without fixed port-ID. \\\hline
        \end{tabu}
        \caption{DSDL directory structure example}\label{fig:dsdl_directory_structure_example}
    \end{figure}
\end{remark}

\subsection{Elements of data type definition}\label{sec:dsdl_elements_of_data_type_definition}

데이터 타입 정의 파일은 \emph{data structure description language} (DSDL)에서 언급한 데이터 타입의 특정 버전에 대한 완벽한 설명을 포함하고 있다.

데이터 타입 정의는 \emph{field attributes}는 순서대로 빈 상태도 가능하고 \emph{constant attributes}는 순서에 상관없이 빈 상태를 포함한다.

데이터 타입은 \emph{structure object}나 \emph{tagged union object} 중에 하나를 서술할 수 있다.
구조체 객체의 값은 field attribute들의 모든 값의 function이다.
태그된 union 객체는 적어도 2개 field attributes로 구성되지만,
한번에 하나의 field attribute 값만 가질 수 있다.
태그된 union 객체의 값은 field attribute 값의 function이고 moment와 언급한 field attribute의 값을 유지하고 있다.

field attribute는 정적 정의된 타입의 이름을 붙여서 동적으로 할당된 값을 표현한다. 포함하고 있는 객체의 멤버로서 네트워크 상에서 교환이 가능하다.
padding field attribute는 field attribute의 특별한 경우로 데이터 정렬 목적으로 사용된다.;
이런 필드에는 이름을 붙이지 않는다.

constant attribute는 정적으로 정의된 타입에 대해서 이름을 붙여서 정적으로 정의된 값을 표현한다.
constants는 네트워크로 절대 교환이 이뤄지지 않는다. 그 이유는 데이터 타입의 호환 정의를 공유함으로써 모든 관련 노드들이 이미 알고 있다고 가정하기 때문이다.

Constant 값들은 \emph{DSDL expressions}를 통해서 정의되며,
DSDL definition 처리하는 때에 evaluation된다.
\emph{expression types}라는 특별한 타입의 카테고리가 있는데,
expression evaluation 동안에만 사용되며 네트워크를 통해 교환할 수 없다.

데이터 타입 정의는 여러 추가 엘리먼트를 포함할 수도 있으며 이는 나중에 다루기로 한다.
deprecation 마커(해당 데이터 타입이 새로운 설계에 더 이상 사용을 추천하지 않음) 혹은 assertion이(DSDL 처리 툴에서 데이터 타입 설계자가 정적으로 유효성을 검증하기 위해서 사용된 특별한 구문) 여기에 속한다.

서비스 타입 정의의 특별한 경우:
인스턴스나 시리얼화 될 수 없으며 속성을 포함하지 않으며,
정확히 2개 내부 데이터 타입\footnote{
    A service type can be thought of as a specialized namespace that contains two types and
    has some of the properties of a type, such as name and version.
} 정의로 구성되어 있다.
내부 타입은 서비스 요청 타입과 서비스 응답 타입으로 \emph{service response marker}로 구분된다.
unutterable\footnote{%
Cannot be referred to. Another commonly used term is ``Voldemort type''.
}하고 \emph{parent service type}로부터 속성의\footnote{Like version numbers or deprecation status.} 일부를 얻는다는 점을 제외하고는 일반 데이터 타입과 동일하다.

\subsection{Serialization}

UAVCAN 노드들 사이에서 교환이 이뤄지는 모든 객체는 잘 정의된 \emph{serialized representation}을 가지고 있다.
객체의 값과 의미는 serialized representation으로부터 모호함 없이 복구될 수 있고 객체의 타입을 알 수 있도록 제공된다.
이런 복구 처리를 \emph{deserialization}라고 부른다.

\label{sec:dsdl_bit_length_set}
A serialized representation는 바이너리의 연속(bits)으로 되어 있다.;
직렬화 표현 내부 비트의 개수를 \emph{bit length}라고 부른다.
데이터 타입의 \emph{bit length set}란 데이터 타입의 인스턴스들인 객체들의 모든 가능한 직렬화 표현의 bit 길이 값의 집합을 말한다.

어떤 데이터 타입의 bit 길이 집합이 1개 이상의 엘리먼트를 포함하면 이를 \emph{variable length}라고 말한다.
반대 경우를 \emph{fixed length}라고 한다.

직렬화 메시지의 데이터 타입 혹은 네트워크 상에서 교환되는 서비스 객체는 각각 subject-ID 혹은 service-ID로부터 복구된다.
이는 다른 메타데이터와 함께 직렬화 객체에 붙여서 transport 계층 스펙 (chapter~\ref{sec:transport})에서 정한 방식을 따른다.
포트 식별 및 데이터 타입 매핑에 관한 추가 정보는 section~\ref{sec:basic_subjects_and_services}를 참고하자.

bit 길이 집합은 서비스 타입에서는(request와 response 타입) 정의되지 않는데 이유는 서비스 타입은 인스턴스화 되지 않기 때문이다.