\section{Architecture}

\subsection{General principles}

UAVCAN 아키텍처에 따라 DSDL에서 사용자는 2가지 종류의 데이터 타입을 정의할 수 있다:
메시지 타입과 서비스 타입
메시지 타입은 publish-subscribe 상에서 데이터 교환에 사용되며 1:다 메시지 링크는 서브젝트-ID로 식별한다. 서비스 타입은 request-response를 수행하는데 사용하며 RPC와 같이 1:1 교환에서 서비스-ID로 식별한다.
서비스 타입은 정확히 2개 내부 데이터 타입으로 구성된다:
그 중에 하나는 request 타입(클라이언트에서 서버로 전송)이고,
나머지 하나는 response 타입(서버에서 클라이언트로 전송)이다.

UAVCAN의 deterministic 속성을 따라서 메시지나 서비스 객체의 크기는 정적으로 이미 알고 있는 크기 이내에 한정된다.
가변길이 엔트티는 항상 데이터 타입 디자이너가 정의한 고정 길이 제한을 가진다.

DSDL정의는 정적 타입이다.

DSDL은 데이터 타입 버전관리를 위해 잘 정의되어 있다. 이를 통해 데이터 타입 유지보수자가 배포한 데이터 타입의 하위 호환을 되도록 변경할 수 있다.

DSDL은 확장 가능한 정적 분석을 지원하도록 설계되었다. 하위 바이너리 호환성과 데이터 필드 레이아웃과 같이 데이터 타입 정의의 중요한 속성은 이를 사용하는 시스템이 운영되기 전에 자동 소프트웨어 도구로 검증 및 검사가 가능하다.

DSDL정의는 타겟 프로그래밍 언어에서 직렬화 소스코드 데이터 타입으로 자동 생성될 수 있다.
DSDL 정의를 기반으로 직렬화 코드를 생성하는 기능을 가진 도구를 \emph{DSDL compiler}라고 부른다.
좀더 일반적으로는 말하자면 DSDL 정의로 동작하도록 설계된 소프트웨어 도구를 \emph{DSDL processing tool}라고 부른다.

\subsection{Data types and namespaces}

모든 데이터 타입은 \emph{namespace} 내부에 위치한다.
네임스페이스는 더 상위레벨 네임스페이스에 포함될 수 있으며 트리구조를 가진다.

트리 구조의 최상단에 있는 네임스페이스를 \emph{root namespace}라고 부른다.
다른 네임스페이스 내부에 위치하고 있는 네임스페이스를 \emph{nested namespace}라고 부른다.

데이터 타입은 네임스페이스와 이름\emph{short name}으로 식별된다.
데이터 타입의 이름은 네임스페이트를 제외한 타입의 이름이다.

데이터 타입의 \emph{full name}은 이름과 네임스페이스 이름들로 구성된다.전체 이름에 포함된 이름과 네임스페이스는를 \emph{name components}라고 부른다.
이름 컴포넌트들은 순서를 가진다: 루트 네임스페이스는 항상 맨 앞에 오고 다음으로 nested 네임스페이스가 온다.
전체 이름에서 이름(short name)은 항상 마지막에 위치한다.
전체 이름은 ASCII dot 문자 ``\verb|.|'' (ASCII code 46)를 통해서 이름 컴포넌트들을 연결시킨다.

\emph{full namespace} 이름은 이름(short name)과 component 구분자를 제외한 전체 이름이다.

\emph{sub-root namespace}은 netsted 네임스페이스로 루트 네임스페이스 바로 밑에 위치한다.
루트 네임스페이스 아래에 위치하고 있는 데이터 타입은 하위루트 네임스페이스를 가지지 않는다.

이름 구조는 figure~\ref{fig:dsdl_data_type_name_structure} 그림으로 표현하였다.

\begin{figure}[H]
    $$
    \overbrace{
        \underbrace{
            \underbrace{\texttt{\huge{uavcan}}}_{\substack{\text{root} \\ \text{namespace}}}%
            \texttt{\huge{.}}%
            \underbrace{\texttt{\huge{node}}}_{\substack{\text{nested, also} \\ \text{sub-root} \\ \text{namespace}}}%
            \texttt{\huge{.}}%
            \underbrace{\texttt{\huge{port}}}_{\substack{\text{nested} \\ \text{namespace}}}%
        }_{\text{full namespace}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{GetInfo}}}_{\text{short name}}
    }^{\text{full name}}
    $$
    \caption{Data type name structure\label{fig:dsdl_data_type_name_structure}}
\end{figure}

전체 네임스페이스 이름의 집합과 전체 데이터 타입 이름의 집합은 서로 교차되지 않는다.\footnote{%
    예제로 네임스페이스 ``\texttt{vendor.example}''와 데이터 타입 ``\texttt{vendor.example.1.0}''는 서로 상호배제되는 형태다.
    이 예제에서 보여준 데이터 타입 이름은 이름 규칙에 위배된다. 이는 별도 섹션에서 다룰 예정이다.
}.

데이터 타입 이름과 네임스페이스 이름은 대소문자를 구분한다.
하지만 대소문자가 다른 이름들은 허용하지 않는다.\footnote{%
    대소문자를 구분하지 않는 파일시스템에서는 문제를 야기할 수 있기 때문이다.
}.
다시 말하면 대소문자만 다른 한쌍의 이름은 이름 충돌이 발생할 수 있다.


A name component consists of alphanumeric ASCII characters (which are: \verb|A-Z|, \verb|a-z|, and \verb|0-9|)
and underscore (``\verb|_|'', ASCII code 95).
An empty string is not a valid name component.
The first character of a name component shall not be a digit.
A name component shall not match any of the reserved word patterns,
which are listed in table~\ref{table:dsdl_reserved_word_patterns}.

The length of a full data type name shall not exceed 255
characters\footnote{This includes the name component separators, but not the version.}.

Every data type definition is assigned a major and minor version number pair.
In order to uniquely identify a data type definition, its version numbers shall be specified.
In the following text, the term \emph{version} without a majority qualifier refers to
a pair of major and minor version numbers.

Valid data type version numbers range from 0 to 255, inclusively.
A data type version where both major and minor components are zero is not allowed.

\subsection{File hierarchy}

DSDL data type definitions are contained in UTF-8 encoded text files with a file name extension \verb|.uavcan|.

One file defines exactly one version of a data type,
meaning that each combination of major and minor version numbers shall be unique per data type name.
There may be an arbitrary number of versions of the same data type defined alongside each other,
provided that each version is defined at most once.
Version number sequences can be non-contiguous,
meaning that it is allowed to skip version numbers or remove existing definitions that are neither oldest nor newest.

A data type definition may have an optional fixed port-ID\footnote{Chapter~\ref{sec:basic}.} value specified.

The name of a data type definition file is constructed from the following entities
joined via the ASCII dot character ``\verb|.|'' (ASCII code 46), in the specified order:
\begin{itemize}
    \item Fixed port-ID in decimal notation, unless a fixed port-ID is not provided for this definition.
    \item Short name of the data type (mandatory, always non-empty).
    \item Major version number in decimal notation (mandatory).
    \item Minor version number in decimal notation (mandatory).
    \item File name extension ``\verb|uavcan|'' (mandatory).
\end{itemize}

\begin{figure}[H]
    $$
    \overbrace{%
        \underbrace{\texttt{\huge{432}}}_{\substack{\text{fixed} \\ \text{port-ID}}}%
        \texttt{\huge{.}}%
    }^{\text{optional}}%
    \overbrace{%
        \underbrace{\texttt{\huge{GetInfo}}}_{\substack{\text{short name}}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{1.0}}}_{\substack{\text{version} \\ \text{numbers}}}%
        \texttt{\huge{.}}%
        \underbrace{\texttt{\huge{uavcan}}}_{\text{file extension}}%
    }^{\text{mandatory}}
    $$
    \caption{Data type definition file name structure\label{fig:dsdl_definition_file_name_structure}}
\end{figure}

DSDL namespaces are represented as directories, where one directory defines exactly one namespace, possibly nested.
The name of the directory defines the name of its data type name component.
A directory defining a namespace will always define said namespace in its entirety,
meaning that the contents of a namespace cannot be spread across different directories sharing the same name.
One directory cannot define more than one level of
nesting\footnote{%
    For example, ``\texttt{foo.bar}'' is not a valid directory name.
    The valid representation would be ``\texttt{bar}'' nested in ``\texttt{foo}''.
}.

\begin{remark}
    \begin{figure}[H]
        \begin{tabu}{|l|X|} \hline
            \rowfont{\bfseries}
            Directory tree & Entry description \\\hline

            \texttt{vendor\_x/} &
            Root namespace \texttt{vendor\_x}. \\\cline{2-2}

            \texttt{\qquad{}foo/} &
            Nested namespace (also sub-root) \texttt{vendor\_x.foo}. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}100.Run.1.0.uavcan} &
            Data type definition v1.0 with fixed service-ID 100. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}100.Status.1.0.uavcan} &
            Data type definition v1.0 with fixed subject-ID 100. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}ID.1.0.uavcan} &
            Data type definition v1.0 without fixed port-ID. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}ID.1.1.uavcan} &
            Data type definition v1.1 without fixed port-ID. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}bar\_42/} &
            Nested namespace \texttt{vendor\_x.foo.bar\_42}. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}101.List.1.0.uavcan} &
            Data type definition v1.0 with fixed service-ID 101. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}102.List.2.0.uavcan} &
            Data type definition v2.0 with fixed service-ID 102. \\\cline{2-2}

            \texttt{\qquad{}\qquad{}\qquad{}ID.1.0.uavcan} &
            Data type definition v1.0 without fixed port-ID. \\\hline
        \end{tabu}
        \caption{DSDL directory structure example}\label{fig:dsdl_directory_structure_example}
    \end{figure}
\end{remark}

\subsection{Elements of data type definition}\label{sec:dsdl_elements_of_data_type_definition}

A data type definition file contains an exhaustive description of a particular version of the said data type in the
\emph{data structure description language} (DSDL).

A data type definition contains an ordered, possibly empty collection of \emph{field attributes} and/or
unordered, possibly empty collection of \emph{constant attributes}.

A data type may describe either a \emph{structure object} or a \emph{tagged union object}.
The value of a structure object is a function of the values of all of its field attributes.
A tagged union object is formed from at least two field attributes,
but it is capable of holding exactly one field attribute value at any given time.
The value of a tagged union object is a function of which field attribute value
it is holding at the moment and the value of said field attribute.

A field attribute represents a named dynamically assigned value of a statically defined type
that can be exchanged over the network as a member of its containing object.
A padding field attribute is a special kind of field attribute which is used for data alignment purposes;
such field attributes are not named.

A constant attribute represents a named statically defined value of a statically defined type.
Constants are never exchanged over the network, since they are assumed to be known to all involved nodes
by virtue of them sharing compatible definitions of the data type.

Constant values are defined via \emph{DSDL expressions},
which are evaluated at the time of DSDL definition processing.
There is a special category of types called \emph{expression types},
instances of which are used only during expression evaluation
and cannot be exchanged over the network.

Data type definitions can also contain various auxiliary elements reviewed later,
such as deprecation markers (notifying its users that the data type is no longer recommended for new designs)
or assertions (special statements introduced by data type designers
which are statically validated by DSDL processing tools).

Service type definitions are a special case:
they cannot be instantiated or serialized, they do not contain attributes,
and they are composed of exactly two inner data type definitions\footnote{
    A service type can be thought of as a specialized namespace that contains two types and
    has some of the properties of a type, such as name and version.
}.
These inner types are the service request type and the service response type,
separated by the \emph{service response marker}.
They are otherwise ordinary data types except that they are unutterable\footnote{%
    Cannot be referred to. Another commonly used term is ``Voldemort type''.
}
and they derive some of their properties\footnote{Like version numbers or deprecation status.}
from their \emph{parent service type}.

\subsection{Serialization}

Every object that can be exchanged between UAVCAN nodes has a well-defined \emph{serialized representation}.
The value and meaning of an object can be unambiguously recovered from its serialized representation,
provided that the type of the object is known.
Such recovery process is called \emph{deserialization}.

\label{sec:dsdl_bit_length_set}
A serialized representation is a sequence of binary digits (bits);
the number of bits in a serialized representation is called its \emph{bit length}.
A \emph{bit length set} of a data type refers to the set of bit length values of all possible
serialized representations of objects that are instances of the data type.

A data type whose bit length set contains more than one element is said to be \emph{variable length}.
The opposite case is referred to as \emph{fixed length}.

The data type of a serialized message or service object exchanged over the network
is recovered from its subject-ID or service-ID, respectively,
which is attached to the serialized object, along with other metadata, in a manner dictated by the applicable
transport layer specification (chapter~\ref{sec:transport}).
For more information on port identifiers and data type mapping refer to section~\ref{sec:basic_subjects_and_services}.

The bit length set is not defined on service types (only on their request and response types)
because they cannot be instantiated.
