\section{Compatibility and versioning}\label{sec:dsdl_versioning}

\subsection{Rationale}

데이터 타입 정의는 어플리케이션의 니즈에 더 잘 맞도록 개선되면서 시간이 지날수록 진화하게 된다.
UAVCAN은 데이터 타입 디자이너가 하위 호환이나 기능 안정성을 보장하기 위해서 데이터 타입 정의를 수정하고 이용하도록 규칙들을 정의할 수 있다.

\subsection{Semantic compatibility}\label{sec:dsdl_semantic_compatibility}

데이터 타입 $A$은 데이터 타입 $B$와 \emph{semantically compatible}하다고 하는 경우는 만약에 관련 어플리케이션의 동작 속성이 항상 $A$ 를 $B$로 대체 가능한 경우이다.
의미 호환이 가능한 속성은 교환법칙이 성립된다.

\begin{remark}[breakable]
    The following two definitions are semantically compatible and can be used interchangeably:

    \begin{minted}{python}
        uint16 FLAG_A = 1
        uint16 FLAG_B = 256
        uint16 flags
        @extent 16
    \end{minted}

    \begin{minted}{python}
        uint8 FLAG_A = 1
        uint8 FLAG_B = 1
        uint8 flags_a
        uint8 flags_b
        @extent 16
    \end{minted}

    필드와 일정한 속성이 달라지므로 주의를 주는 것이 필요하다.
    제공된 정의로부터 자동생성된 소스 코드는 교체하기 위해서 어플리케이션에서 변경이 필요할 수 있다.;
    하지만 소스 코드 레벨 어플리케이션 호환성은 데이터 타입 호환성과 관련이 없다.


    다음 수퍼타입은 의미상 제거된 필드의 의미에 따라서 위에 있는 것과 의미상 호환이 될 수도 안될 수도 있다.:

    \begin{minted}{python}
        uint8 FLAG_A = 1
        uint8 flags_a
        @extent 16
    \end{minted}
\end{remark}

\begin{remark}
    Let node $A$ publish messages of the following type:

    \begin{minted}{python}
        float32 foo
        float64 bar
        @extent 128
    \end{minted}

    Let node $B$ subscribe to the same subject using the following data type definition:

    \begin{minted}{python}
        float32 foo
        float64 bar
        int16   baz  # Extra field; implicit zero extension rule applies.
        @extent 128
    \end{minted}

    Let node $C$ subscribe to the same subject using the following data type definition:

    \begin{minted}{python}
        float32 foo
        # The field 'bar' is missing; implicit truncation rule applies.
        @extent 128
    \end{minted}

    Provided that the semantics of the added and omitted fields allow it,
    the nodes will be able to interoperate successfully despite using different data type definitions.
\end{remark}

\subsection{Versioning}

\subsubsection{General assumptions}

버전닝의 개념은 컴포지트 데이터 타입에만 적용된다.
특별히 언급하지 않으면 이 섹션에 ``data type''에 대한 모든 레퍼런스는 컴포지트 데이터 타입을 의미한다.

데이터 타입은 전체 이름으로 식별되고 모든 루트 네임스페이스는 유일한 이름을 갖는다고 가정한다.
모든 데이터 타입의 1개 이상의 버전이 있다.

데이터 타입 정의는 전체 이름과 버전 넘버의 쌍으로 식별된다.
달리 말하면, 버전 넘버가 다른 데이터 타입의 다양한 정의가 있을 수 있다.

\subsubsection{Versioning principles}

모든 데이터 타입 정의는 버전 넘버의 쌍을 가진다. ---
메이저 버전 넘버와 마이너 버전 넘버은 의미있는 버전을 매기는 원칙을 따른다.

다음 정의의 목적을 위해서 데이터 타입 정의의 \emph{release}는 의도된 사용자나 일반 대중에게 데이터 타입의 정의를 공개하는 것을 의미하거나 제품 시스템에서 데이터 타입의 정의의 사용을 개시하는 목적이다.

어플리케이션 동작을 보장하고 데이터 타입 정의와 관련된 강건한 마이그레이션 경로를 보장하기 위해서 동일한 전체 이름과 동일한 메이저 버전 넘버를 공유하는 모든 데이터 타입 정의는 의미적으로 서로 호환된다.

버전닝을 매기는 원칙은 데이터 타입의 이름이 변경되는 지점의 시나리오로 확장되지 않는데,
왜냐하면 이렇게 하면 본질적으로 새로운 데이터 타입의 릴리즈로 해석되기 때문이다.
이는 모든 호환 요구사항으로부터 디자이너를 안심시킬 수 있다.
새로운 데이터 타입이 처음으로 릴리즈되는 때에,
처음 정의의 버전 넘버는 ``1.0'' (major 1, minor 0)이 할당된다.

UAVCAN을 활용하여 어플리케이션의 예측가능성과 기능정 안정성을 확보하기 위해서,
일단 데이터 타입 정의가 릴리즈시키는 것을 추천하고 DSDL 소스 텍스트, 이름, 버전 넘버, 고정 port-ID, 확장, 실링 및 기타 속성은 다음과 같은 예외를 제외하고는 수정이 되지 않는다.:
\begin{itemize}
    \item Whitespace changes of the DSDL source text are allowed,
          excepting string literals and other semantically sensitive contexts.

    \item Comment changes of the DSDL source text are allowed as long as such changes
          do not affect semantic compatibility of the definition.

    \item A deprecation marker directive (section~\ref{sec:dsdl_directives}) can be added or removed\footnote{%
              Removal is useful when a decision to deprecate a data type definition is withdrawn.
          }.
\end{itemize}
특정 버전의 데이터 타입 정의가 릴리즈 되고 난 이후에는 고정 port-id를 추가 혹은 제거는 허용되지 않는다.

따라서 큰 변화는 동일한 데이터 타입의 새로운 정의를 릴리즈하는 경우에만 적용된다.(예) 새로운 버전)
데이터 타입의 새로운 정의를 위해서 동일한 메이저 넘버를 유지하는 것이 바람직하고 가능하다면,
새로운 정의의 마이너 버전 넘버는 새로운 정의를 사용하기 전에 가장 최신의 기존 마이너 버전 넘버보다 큰 수로 정할 수 있다.
반면에 메이저 버전 넘버는 1씩 증가하고 마이너 버전은 0으로 설정된다.

메이저 버전 넘버가 0이 되면 위에 원칙에 대한 예외가 적용된다.
메이저 버전 넘버가 0인 데이터 타입 정의는 어떠한 호환성 요구사항도 적용되지 않는다.
메이저 버전 넘버가 0으로 릴리즈된 데이터 타입 정의는 호환성에 대한 고려없이 임의의 방식으로 변경될 수 있다.
하지만 불변성의 원칙을 따르기 위해서 가장 최신의 기존 정의보다 마이너 버전 넘버가 1이 증가된 차기 정의를 릴리즈하는 것을 추천한다.

어떤 데이터 타입에 대해서 버전마다 많아야 하나의 정의가 있다.
달리 말하면 정의는 데이터 타입 이름과 버전 넘버 쌍의 조합마다 하나이거나 없거나 둘 중에 하나이다.

동일한 이름 아래에서 모든 데이터 타입은 동일한 종류가 된다.
달리 말하면 데이터 타입의 첫음 릴리즈된 정의가 메시지 종류 중에 하나라면 모든 버전도 메시지 종류 중에 하나여야 한다.

동일한 이름과 메이저 버전 넘버 아래에서 모든 데이터 타입은 동일한 확장과 동일한 실링 상태를 공유해야만 한다.
따라서 다음과 같이 다음과 같이 권고한다:
\begin{itemize}
    \item Avoid marking types sealed, especially complex types,
    because it is likely to render their evolution impossible.

    \item When the first version is released, its extent should be sufficiently large
    to permit addition of new fields in the future.
    Since the value of extent does not affect the network traffic, it is safe to pick a large value
    without compromising the temporal properties of the system.
\end{itemize}

\subsubsection{Fixed port identifier assignment constraints}

The following constraints apply to fixed port-ID assignments:
\begin{align*}
    \exists P(x_{a.b})                          &\rightarrow \exists P(x_{a.c})
    &\mid&\ b < c;\ x \in (M \cup S)
    \\
    \exists P(x_{a.b})                          &\rightarrow         P(x_{a.b}) =    P(x_{a.c})
    &\mid&\ b < c;\ x \in (M \cup S)
    \\
    \exists P(x_{a.b}) \land \exists P(x_{c.d}) &\rightarrow         P(x_{a.b}) \neq P(x_{c.d})
    &\mid&\ a \neq c;\ x \in (M \cup S)
    \\
    \exists P(x_{a.b}) \land \exists P(y_{c.d}) &\rightarrow         P(x_{a.b}) \neq P(y_{c.d})
    &\mid&\ x \neq y;\ x \in T;\ y \in T;\ T = \left\{ M, S \right\}
\end{align*}
where $t_{a.b}$ denotes a data type $t$ version $a.b$ ($a$ major, $b$ minor);
$P(t)$ denotes the fixed port-ID (whose existence is optional) of data type $t$;
$M$ is the set of message types, and $S$ is the set of service types.

\subsubsection{Data type version selection}

DSDL 컴파일러는 모든 유효한 데이터 타입 버전을 따로따로 컴파일해야만 한다.
이렇게 해야 어플리케이션이 모든 메이저와 마이너 버전 조합으로부터 선택할 수 있다.

전송이 시작되면 데이터 타입의 메이저 버전은 어플리케이션의 재량으로 선택된다.
마이너 버전은 선택된 메이저 버전 중에 하나
When emitting a transfer, the major version of the data type is chosen at the discretion of the application.
The minor version should be the newest available one under the chosen major version.

When receiving a transfer, the node deduces which major version of the data type to use
from its port identifier (either fixed or non-fixed).
The minor version should be the newest available one under the deduced major version\footnote{%
    Such liberal minor version selection policy poses no compatibility risks since all definitions under the same
    major version are compatible with each other.
}.

It follows from the above two rules that when a node is responding to a service request,
the major data type version used for the response transfer shall be the same that is used for the request transfer.
The minor versions may differ, which is acceptable due to the major version compatibility requirements.

\begin{remark}[breakable]
    A simple usage example is provided in this intermission.

    Suppose a vendor named ``Sirius Cybernetics Corporation'' is contracted to design a
    cryopod management data bus for a colonial spaceship ``Golgafrincham B-Ark''.
    Having consulted with applicable specifications and standards, an engineer came up with the following
    definition of a cryopod status message type (named \verb|sirius_cyber_corp.b_ark.cryopod.Status|):

    \begin{minted}{python}
        # sirius_cyber_corp.b_ark.cryopod.Status.0.1

        float16 internal_temperature    # [kelvin]
        float16 coolant_temperature     # [kelvin]

        uint8 FLAG_COOLING_SYSTEM_A_ACTIVE = 1
        uint8 FLAG_COOLING_SYSTEM_B_ACTIVE = 2
        # Status flags in the lower bits.
        uint8 FLAG_PSU_MALFUNCTION = 32
        uint8 FLAG_OVERHEATING     = 64
        uint8 FLAG_CRYOBOX_BREACH  = 128
        # Error flags in the higher bits.
        uint8 flags  # Storage for the above defined flags (this is not the recommended practice).

        @extent 1024 * 8  # Pick a large extent to allow evolution. Does not affect network traffic.
    \end{minted}

    The definition is then deployed to the first prototype for initial laboratory testing.
    Since the definition is experimental, the major version number is set to zero in order to signify the
    tentative nature of the definition.
    Suppose that upon completion of the first trials it is identified that the units should track their
    power consumption in real time for each of the three redundant power supplies independently.

    It is easy to see that the amended definition shown below is not semantically compatible
    with the original definition; however, it shares the same major version number of zero, because the backward
    compatibility rules do not apply to zero-versioned data types to allow for low-overhead experimentation
    before the system is deployed and fielded.

    \begin{minted}{python}
        # sirius_cyber_corp.b_ark.cryopod.Status.0.2

        truncated float16 internal_temperature    # [kelvin]
        truncated float16 coolant_temperature     # [kelvin]

        saturated float32 power_consumption_0     # [watt] Power consumption by the redundant PSU 0
        saturated float32 power_consumption_1     # [watt] likewise for PSU 1
        saturated float32 power_consumption_2     # [watt] likewise for PSU 2
        # breaking compatibility with Status.0.1 is okay because the major version is 0

        uint8 FLAG_COOLING_SYSTEM_A_ACTIVE = 1
        uint8 FLAG_COOLING_SYSTEM_B_ACTIVE = 2
        # Status flags in the lower bits.
        uint8 FLAG_PSU_MALFUNCTION = 32
        uint8 FLAG_OVERHEATING     = 64
        uint8 FLAG_CRYOBOX_BREACH  = 128
        # Error flags in the higher bits.
        uint8 flags  # Storage for the above defined flags (this is not the recommended practice).

        @extent 512 * 8  # Extent can be changed freely because v0.x does not guarantee compatibility.
    \end{minted}

    The last definition is deemed sufficient and is deployed to the production system
    under the version number of 1.0: \verb|sirius_cyber_corp.b_ark.cryopod.Status.1.0|.

    Having collected empirical data from the fielded systems, the Sirius Cybernetics Corporation has
    identified a shortcoming in the v1.0 definition, which is corrected in an updated definition.
    Since the updated definition, which is shown below, is semantically compatible\footnote{%
        The topic of data serialization is explored in detail in section~\ref{sec:dsdl_data_serialization}.
    } with v1.0, the major version number is kept the same and the minor version number is incremented by one:

    \begin{minted}{python}
        # sirius_cyber_corp.b_ark.cryopod.Status.1.1

        saturated float16 internal_temperature    # [kelvin]
        saturated float16 coolant_temperature     # [kelvin]

        float32[3] power_consumption    # [watt] Power consumption by the PSU

        bool flag_cooling_system_a_active
        bool flag_cooling_system_b_active
        # Status flags (this is the recommended practice).

        void3   # Reserved for other flags

        bool flag_psu_malfunction
        bool flag_overheating
        bool flag_cryobox_breach
        # Error flags (this is the recommended practice).

        @extent 512 * 8  # Extent is to be kept unchanged now to avoid breaking compatibility.
    \end{minted}

    Since the definitions v1.0 and v1.1 are semantically compatible,
    UAVCAN nodes using either of them can successfully interoperate on the same bus.

    Suppose further that at some point a newer version of the cryopod module,
    equipped with better temperature sensors, is released.
    The definition is updated accordingly to use \verb|float32| for the temperature fields instead of \verb|float16|.
    Seeing as that change breaks the compatibility, the major version number has to be incremented by one,
    and the minor version number has to be reset back to zero:

    \begin{minted}{python}
        # sirius_cyber_corp.b_ark.cryopod.Status.2.0

        float32 internal_temperature    # [kelvin]
        float32 coolant_temperature     # [kelvin]

        float32[3] power_consumption    # [watt] Power consumption by the PSU

        bool flag_cooling_system_a_active
        bool flag_cooling_system_b_active
        void3
        bool flag_psu_malfunction
        bool flag_overheating
        bool flag_cryobox_breach

        @extent 768 * 8  # Since the major version number is different, extent can be changed.
    \end{minted}

    Imagine that later it was determined that the module should report additional status information
    relating to the coolant pump.
    Thanks to the implicit truncation (section \ref{sec:dsdl_serialization_implicit_truncation}),
    implicit zero extension (section \ref{sec:dsdl_serialization_implicit_zero_extension}),
    and the delimited serialization (section \ref{sec:dsdl_serialization_composite_non_sealed}),
    the new fields can be introduced in a semantically-compatible way without releasing
    a new major version of the data type:

    \begin{minted}{python}
        # sirius_cyber_corp.b_ark.cryopod.Status.2.1

        float32 internal_temperature    # [kelvin]
        float32 coolant_temperature     # [kelvin]

        float32[3] power_consumption    # [watt] Power consumption by the PSU

        bool flag_cooling_system_a_active
        bool flag_cooling_system_b_active
        void3
        bool flag_psu_malfunction
        bool flag_overheating
        bool flag_cryobox_breach

        float32 rotor_angular_velocity  # [radian/second] (usage of RPM would be non-compliant)
        float32 volumetric_flow_rate    # [meter^3/second]
        # Coolant pump fields (extension over v2.0; implicit truncation/extension rules apply)
        # If zero, assume that the values are unavailable.

        @extent 768 * 8
    \end{minted}

    It is also possible to add an optional field at the end wrapped into a variable-length
    array of up to one element, or a tagged union where the first field is empty
    and the second field is the wrapped value.
    In this way, the implicit truncation/extension rules would automatically make such optional field
    appear/disappear depending on whether it is supported by the receiving node.

    Nodes using v1.0, v1.1, v2.0, and v2.1 definitions can coexist on the same network,
    and they can interoperate successfully as long as they all support at least v1.x or v2.x.
    The correct version can be determined at runtime from the port identifier assignment as described in
    section~\ref{sec:basic_subjects_and_services}.

    In general, nodes that need to maximize their compatibility are likely to employ all existing major versions of
    each used data type.
    If there are more than one minor versions available, the highest minor version within the major version should
    be used in order to take advantage of the latest changes in the data type definition.
    It is also expected that in certain scenarios some nodes may resort to publishing the same message type
    using different major versions concurrently to circumvent compatibility issues
    (in the example reviewed here that would be v1.1 and v2.1).

    The examples shown above rely on the primitive scalar types for reasons of simplicity.
    Real applications should use the type-safe physical unit definitions available in the SI namespace instead.
    This is covered in section~\ref{sec:application_functions_si}.
\end{remark}
